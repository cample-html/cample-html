/*!
 * cample-html v0.0.2 (https://github.com/cample-html/cample-html)
 * Copyright (c) 2024 Anton Maklakov
 * Licensed under MIT (https://github.com/cample-html/cample-html/blob/main/LICENSE)
 */
!function(e,t){"object"==typeof module&&module.exports?module.exports=t():"function"==typeof define&&define.amd?define([],t):e.CampleHTML=e.CampleHTML||t()}("undefined"!=typeof self?self:this,(function(){return function(){"use strict";const e=e=>{throw new Error(e)},t="TEMPLATE",o="data-cample",r="data-src",n="data-method",s="data-status",a=()=>document,d=t=>{"string"!=typeof t&&e("Bad response");const o=(new DOMParser).parseFromString(`<template>${t}</template>`,"text/html").childNodes[0].childNodes[0].firstChild,r=o.content,n=r.querySelectorAll("script");for(let e=0;e<n.length;e++){const t=n[e];r.removeChild(t)}return o},i=(t,o,r,n,a,i,l,c)=>{const h=new XMLHttpRequest;if(h.open(o.toUpperCase(),r,!0),h.overrideMimeType("text/html"),h.withCredentials=n,i)if("object"!=typeof(u=i)||Array.isArray(u)||null===u)e('The "header" property does not have a value object');else for(const t in i){const[o,r]=t;if("string"==typeof r)try{h.setRequestHeader(o,r)}catch(e){throw e}else e("Header has no string value")}var u;const p=void 0!==c;h.timeout=a;const m=()=>{c.status!==h.status&&(c.status=h.status)},f=e=>{e?t.setAttribute(s,e):t.removeAttribute(s)};p?(h.onabort=m,h.onloadend=m,h.onloadstart=m,h.onprogress=m,h.onreadystatechange=m,h.ontimeout=m):h.onprogress=()=>f("loading"),h.onload=p?()=>{m();try{if(200!==h.status)e(`Request error with code ${h.status}`);else{const{response:e}=h,t=d(e);c.element=t}}catch(e){throw e}}:()=>{f();try{if(200!==h.status)e(`Request error with code ${h.status}`);else{const{response:e}=h,o=d(e).content.childNodes,r=t.parentNode;for(let e=0;e<o.length;e++){const n=o[e];r.insertBefore(n,t)}r.removeChild(t)}}catch(e){throw e}},h.onerror=p?e=>{throw m(),e}:e=>{throw f(),e},void 0!==l?h.send(l):h.send()},l={createTemplate:s=>{"string"!=typeof s&&e("template was not found or the type of the passed value is not string");const a=(r=>{const n=(new DOMParser).parseFromString(`<template>${r}</template>`,"text/html").childNodes[0].childNodes[0].firstChild;n.content.children.length>1&&e("Template include only one node with type 'Element'");const s=e=>{switch(e.nodeType){case Node.ELEMENT_NODE:if("pre"===e.tagName)return;break;case Node.TEXT_NODE:if(!/\S/.test(e.textContent))return void e.remove()}for(let t=0;t<e.childNodes.length;t++)s(e.childNodes.item(t))};s(n.content.childNodes[0]);const a=n.content.firstElementChild;return a?.nodeName===t&&null!==a.getAttribute(o)||e(`Other nodes, except those with the name "${t}" and attribute "${o}", are not yet supported`),a})(s),d=a.getAttribute(r);if(d){const t=(a.getAttribute(n)||"GET").toLowerCase();if("get"===t||"post"===t){return({withCredentials:e=!1,timeout:o=0,headers:r,requestBody:n}={})=>{const s={element:void 0,status:0};return i(void 0,t,d,e,o,r,n,s),s}}e("The method has only GET or POST values")}else e('The "source" attribute are not found or empty')}},c=()=>{const s=a().querySelectorAll(`[${o}]`);for(let o=0;o<s.length;o++){const a=s[o];null===a.parentNode&&e('"parentNode" is null'),a.nodeName!==t&&e(`Other nodes, except those with the name "${t}", are not yet supported`);const d=a.getAttribute(r);if(d){const t=(a.getAttribute(n)||"GET").toLowerCase();"get"!==t&&"post"!==t?e("The method has only GET or POST values"):i(a,t,d,!1,0)}}};return"loading"===a().readyState?a().addEventListener("DOMContentLoaded",c):c(),l}()}));
